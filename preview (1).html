<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Three.js Polished Multi-Level Platformer</title>
<style>
  body { margin: 0; overflow: hidden; background: #222; }
  canvas { display: block; }
  #score, #level, #message {
    position: absolute;
    color: white;
    font-family: sans-serif;
    font-size: 20px;
  }
  #score { top: 10px; left: 10px; }
  #level { top: 10px; right: 10px; }
  #message { top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 30px; display:none;}
</style>
</head>
<body>
<div id="score">Score: 0</div>
<div id="level">Level: 1</div>
<div id="message"></div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>

<script>
let scene, camera, renderer;
let player, velocity, canJump=false;
let platforms=[], coins=[];
let keys={}, score=0, levelIndex=0;
const gravity=-0.02, respawnX=0, respawnY=1, jumpVelocity=0.45;
const messageDiv=document.getElementById('message');

// Textures
const loader = new THREE.TextureLoader();
const playerTexture = loader.load('https://threejs.org/examples/textures/brick_diffuse.jpg');
const platformTexture = loader.load('https://threejs.org/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg');
const coinTexture = loader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');

const levels=[
  { platforms:[[0,0,0,6,1,2,false,false],[2,1.5,0,3,0.5,2,false,false],[-2,3,0,3,0.5,2,true,false],[2,4.5,0,2,0.5,2,false,false],[0,6,0,4,0.5,2,false,true]], coins:[[2,2.5,0],[-2,4,0],[0,5.5,0]] },
  { platforms:[[0,0,0,6,1,2,false,false],[-3,1.5,0,3,0.5,2,false,false],[3,3,0,3,0.5,2,true,false],[-2,4.5,0,2,0.5,2,false,false],[0,6,0,3,0.5,2,false,true]], coins:[[-2,2,0],[2,3.5,0],[0,5.5,0]] },
  { platforms:[[0,0,0,6,1,2,false,false],[2,1.5,0,3,0.5,2,false,false],[0,3,0,4,0.5,2,true,false],[-2,4.5,0,3,0.5,2,false,false],[0,6,0,3,0.5,2,false,true]], coins:[[1,2,0],[-1,3.5,0],[0,5,0]] }
];

init();
loadLevel(levelIndex);
animate();

function init(){
  scene=new THREE.Scene();

  // Skybox
  const skyLoader=new THREE.CubeTextureLoader();
  scene.background = skyLoader.load([
    'https://threejs.org/examples/textures/cube/skybox/px.jpg',
    'https://threejs.org/examples/textures/cube/skybox/nx.jpg',
    'https://threejs.org/examples/textures/cube/skybox/py.jpg',
    'https://threejs.org/examples/textures/cube/skybox/ny.jpg',
    'https://threejs.org/examples/textures/cube/skybox/pz.jpg',
    'https://threejs.org/examples/textures/cube/skybox/nz.jpg'
  ]);

  camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
  camera.position.z=10;

  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth,window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Player
  const geo=new THREE.BoxGeometry(1,1,1);
  const mat=new THREE.MeshStandardMaterial({map:playerTexture});
  player=new THREE.Mesh(geo, mat);
  scene.add(player);
  velocity=new THREE.Vector3();

  const light=new THREE.DirectionalLight(0xffffff,1);
  light.position.set(5,10,7);
  scene.add(light);

  document.addEventListener('keydown', e=>keys[e.key]=true);
  document.addEventListener('keyup', e=>keys[e.key]=false);
  window.addEventListener('resize', ()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
  });
}

function loadLevel(idx){
  platforms.forEach(p=>scene.remove(p));
  coins.forEach(c=>scene.remove(c));
  platforms=[]; coins=[];
  player.position.set(respawnX,respawnY,0);
  canJump=false;
  const lvl=levels[idx];
  lvl.platforms.forEach(d=>createPlatform(...d));
  lvl.coins.forEach(d=>createCoin(...d));
  document.getElementById('level').innerText="Level: "+(idx+1);
}

function createPlatform(x,y,z,w,h,d,moving=false,goal=false){
  const geo=new THREE.BoxGeometry(w,h,d);
  const mat=new THREE.MeshStandardMaterial({map:platformTexture, color:goal?0xffd700:0x888888});
  const p=new THREE.Mesh(geo, mat);
  p.position.set(x,y,z);
  p.userData={size:{w,h,d},moving:moving,goal:goal,dir:1};
  scene.add(p);
  platforms.push(p);
}

function createCoin(x,y,z){
  const geo=new THREE.SphereGeometry(0.3,16,16);
  const mat=new THREE.MeshStandardMaterial({map:coinTexture});
  const c=new THREE.Mesh(geo,mat);
  c.position.set(x,y,z);
  scene.add(c);
  coins.push(c);
}

function respawnPlayer(){
  player.position.set(respawnX,respawnY,0);
  velocity.set(0,0,0);
}

function checkCollisions(){
  canJump=false;
  for(let p of platforms){
    const s=p.userData.size;
    const dx=Math.abs(player.position.x-p.position.x);
    const dz=Math.abs(player.position.z-p.position.z);
    if(dx<s.w/2+0.5 && dz<s.d/2+0.5){
      const top=p.position.y+s.h/2;
      const bottom=p.position.y-s.h/2;
      const pyBottom=player.position.y-0.5;
      const pyTop=player.position.y+0.5;

      // Landing on top
      if(pyBottom<=top && pyBottom>=bottom && velocity.y<=0){
        player.position.y=top+0.5;
        velocity.y=0;
        canJump=true;
        if(p.userData.goal){
          messageDiv.innerText="Level Complete!";
          messageDiv.style.display="block";
          setTimeout(()=>{
            messageDiv.style.display="none";
            levelIndex++;
            if(levelIndex>=levels.length){
              alert("You finished all levels! Total Score: "+score);
              levelIndex=0; score=0;
            }
            loadLevel(levelIndex);
          },1000);
        }
      }

      // Head collisions only for static platforms
      if(!p.userData.moving && pyTop>=bottom && pyTop<=top && velocity.y>0){
        player.position.y=bottom-0.5;
        velocity.y=0;
      }
    }
  }
}

function checkCoinCollision(){
  coins.forEach(c=>c.rotation.y+=0.05); // Rotate coins
  for(let i=coins.length-1;i>=0;i--){
    const c=coins[i];
    if(player.position.distanceTo(c.position)<0.7){
      scene.remove(c);
      coins.splice(i,1);
      score++;
      document.getElementById('score').innerText="Score: "+score;
    }
  }
}

function animate(){
  requestAnimationFrame(animate);

  if(keys['ArrowLeft']) player.position.x-=0.1;
  if(keys['ArrowRight']) player.position.x+=0.1;
  if(keys['ArrowUp'] && canJump){ velocity.y=jumpVelocity; canJump=false; }

  velocity.y+=gravity;
  player.position.y+=velocity.y;

  checkCollisions();
  checkCoinCollision();

  platforms.forEach(p=>{
    if(p.userData.moving){
      p.position.x+=0.05*p.userData.dir;
      if(p.position.x>4) p.userData.dir=-1;
      if(p.position.x<-4) p.userData.dir=1;
    }
  });

  if(player.position.y<-5) respawnPlayer();

  // Smooth camera follow
  camera.position.x += (player.position.x - camera.position.x)*0.1;
  camera.position.y += ((player.position.y+5) - camera.position.y)*0.1;
  camera.lookAt(player.position);

  renderer.render(scene,camera);
}
</script>
</body>
</html>